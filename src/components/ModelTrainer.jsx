import { useState, useEffect, useRef } from 'react';
import * as brain from 'brainjs';
import './ModelTrainer.css'; const API_URL = import.meta.env.DEV ? 'http://localhost:5000/api' : '/api'; const ModelTrainer = () => { const [isLoading, setIsLoading] = useState(false); const [trainingStatus, setTrainingStatus] = useState(''); const [trainingError, setTrainingError] = useState(null); const [healthData, setHealthData] = useState([]); const [dataStats, setDataStats] = useState(null); const [modelInfo, setModelInfo] = useState(null); const [trainingProgress, setTrainingProgress] = useState(0); const [trainingMethod, setTrainingMethod] = useState('neural-network'); const [trainingConfig, setTrainingConfig] = useState({ iterations: 2000, batchSize: 64, learningRate: 0.005, hiddenLayers: [32, 16, 8], errorThreshold: 0.003, validationSplit: 0.2, regularization: 0.001 }); const [showAdvancedOptions, setShowAdvancedOptions] = useState(false); const [debugLogs, setDebugLogs] = useState([]); const [trainingMetrics, setTrainingMetrics] = useState({ currentIteration: 0, currentError: 0, validationError: 0, learningRate: 0, timeElapsed: 0, estimatedTimeRemaining: 0, accuracy: 0, classAccuracies: {} }); const [showNetworkVisualization, setShowNetworkVisualization] = useState(false); const [dataQuality, setDataQuality] = useState(null); const canvasRef = useRef(null); const trainingStartTime = useRef(null); useEffect(() => { checkForExistingModel(); fetchDataStats(); fetchDataQuality(); }, []); useEffect(() => { if (showNetworkVisualization && modelInfo?.exists) { drawNetworkVisualization(); } }, [showNetworkVisualization, modelInfo, trainingConfig]); const addDebugLog = (message, type = 'info') => { const timestamp = new Date().toLocaleTimeString(); setDebugLogs(prev => [...prev.slice(-49), { timestamp, message, type }]); }; const clearDebugLogs = () => { setDebugLogs([]); }; const t = (data, dur, col, tcol) => { if (typeof Toastify !== 'undefined') { Toastify({ text: data, duration: dur, gravity: "top", position: "center", style: { background: col, color: tcol } }).showToast(); } }; const checkForExistingModel = async () => { try { setIsLoading(true); setTrainingError(null); addDebugLog('Checking for existing trained model...', 'info'); const response = await fetch(`${API_URL}/model-info`); if (response.ok) { const modelData = await response.json(); if (modelData.exists) { setModelInfo(modelData); const statusMessage = `Found existing ${modelData.method} model trained on ${modelData.recordCount.toLocaleString()} records with ${modelData.iterations.toLocaleString()} iterations. Accuracy: ${modelData.accuracy?.toFixed(2)}%. Last updated: ${new Date(modelData.timestamp).toLocaleString()}`; setTrainingStatus(statusMessage); addDebugLog(`Existing model found: ${modelData.method} with ${modelData.accuracy?.toFixed(2)}% accuracy`, 'success'); if (modelData.method === 'neural-network' && modelData.config) { setTrainingConfig(prev => ({ ...prev, ...modelData.config })); } } else { setTrainingStatus('No trained model found. Please analyze data and train a new model.'); addDebugLog('No existing model found', 'warning'); } } else { setTrainingStatus('No trained model found. Please analyze data and train a new model.'); addDebugLog('No existing model found', 'warning'); } } catch (error) { console.error('Error checking for existing model:', error); setTrainingError(`Error checking for existing model: ${error.message}`); addDebugLog(`Error checking model: ${error.message}`, 'error'); } finally { setIsLoading(false); } }; const fetchDataStats = async () => { try { addDebugLog('Fetching dataset statistics...', 'info'); const response = await fetch(`${API_URL}/data-stats`); if (response.ok) { const stats = await response.json(); setDataStats(stats); addDebugLog(`Dataset stats loaded: ${stats.totalRecords} records`, 'success'); if (stats.dataQuality) { addDebugLog(`Data quality score: ${stats.dataQuality.qualityScore.toFixed(2)}%`, 'info'); } } } catch (error) { console.error('Error fetching data statistics:', error); addDebugLog(`Error fetching stats: ${error.message}`, 'error'); } }; const fetchDataQuality = async () => { try { addDebugLog('Analyzing data quality and correlations...', 'info'); const response = await fetch(`${API_URL}/data-quality`); if (response.ok) { const quality = await response.json(); setDataQuality(quality); if (quality.exists && quality.qualityScore) { addDebugLog(`Data correlation quality: ${quality.qualityScore.toFixed(2)}%`, 'success'); if (quality.qualityScore > 80) { addDebugLog('High quality correlated data detected - using optimized neural network config', 'info'); setTrainingConfig(prev => ({ ...prev, hiddenLayers: [32, 16, 8], learningRate: 0.005, iterations: 2000, errorThreshold: 0.003 })); } else if (quality.qualityScore > 60) { addDebugLog('Moderate quality data - using balanced configuration', 'info'); setTrainingConfig(prev => ({ ...prev, hiddenLayers: [24, 12], learningRate: 0.01, iterations: 1500 })); } else { addDebugLog('Lower quality data - using robust configuration', 'warning'); setTrainingConfig(prev => ({ ...prev, hiddenLayers: [16, 8], learningRate: 0.02, iterations: 3000 })); } } } } catch (error) { console.error('Error fetching data quality:', error); addDebugLog(`Error analyzing data quality: ${error.message}`, 'error'); } }; const fetchHealthDataSample = async () => { try { setIsLoading(true); setTrainingError(null); setTrainingStatus('Loading realistic health data sample for analysis...'); addDebugLog('Loading correlated health data sample...', 'info'); const response = await fetch(`${API_URL}/health-data-sample`); if (!response.ok) { throw new Error(`Failed to fetch health data: ${response.status}`); } const data = await response.json(); if (data && data.records && data.records.length > 0) { setHealthData(data.records); const statusMessage = `Successfully loaded ${data.records.length.toLocaleString()} realistic sample records for analysis. Total records available: ${data.totalRecords.toLocaleString()}`; setTrainingStatus(statusMessage); addDebugLog(`Loaded ${data.records.length} realistic sample records`, 'success'); analyzeDataDistribution(data.records); analyzeDataCorrelations(data.records); } else { setTrainingStatus('No health data available for training. Please generate realistic data first.'); addDebugLog('No health data available', 'warning'); } } catch (error) { console.error('Error fetching health data:', error); setTrainingError(`Error loading health data: ${error.message}`); addDebugLog(`Error loading data: ${error.message}`, 'error'); } finally { setIsLoading(false); } }; const analyzeDataDistribution = (data) => { addDebugLog('Analyzing realistic data distribution...', 'info'); const statusCounts = { normal: 0, abnormal: 0, critical: 0 }; const vitalStatusCounts = { bp: { normal: 0, abnormal: 0, critical: 0 }, hr: { normal: 0, abnormal: 0, critical: 0 }, o2: { normal: 0, abnormal: 0, critical: 0 }, temp: { normal: 0, abnormal: 0, critical: 0 } }; data.forEach(record => { const statuses = [ record.bloodPressureStatus, record.heartRateStatus, record.oxygenLevelStatus, record.temperatureStatus ]; let overallStatus = 'normal'; if (statuses.includes('critical')) { overallStatus = 'critical'; } else if (statuses.includes('abnormal')) { overallStatus = 'abnormal'; } statusCounts[overallStatus]++; vitalStatusCounts.bp[record.bloodPressureStatus]++; vitalStatusCounts.hr[record.heartRateStatus]++; vitalStatusCounts.o2[record.oxygenLevelStatus]++; vitalStatusCounts.temp[record.temperatureStatus]++; }); const total = data.length; const distribution = { normal: (statusCounts.normal / total * 100).toFixed(2), abnormal: (statusCounts.abnormal / total * 100).toFixed(2), critical: (statusCounts.critical / total * 100).toFixed(2) }; setDataStats(prevStats => ({ ...prevStats, distribution, vitalDistribution: vitalStatusCounts, sampleSize: data.length })); addDebugLog(`Overall patient distribution - Normal: ${distribution.normal}%, Abnormal: ${distribution.abnormal}%, Critical: ${distribution.critical}%`, 'info'); const minPercentage = Math.min(parseFloat(distribution.normal), parseFloat(distribution.abnormal), parseFloat(distribution.critical)); const maxPercentage = Math.max(parseFloat(distribution.normal), parseFloat(distribution.abnormal), parseFloat(distribution.critical)); if (maxPercentage / minPercentage > 3) { addDebugLog('Class imbalance detected - consider using weighted loss or balanced sampling', 'warning'); } else { addDebugLog('Good class balance detected - optimal for training', 'success'); } }; const analyzeDataCorrelations = (data) => { addDebugLog('Analyzing vital sign correlations...', 'info'); let correlationCount = 0; let totalPatients = data.length; const correlations = { hypertensionTachycardia: 0, hypoxiaTachycardia: 0, feverTachycardia: 0, multiSystemCritical: 0 }; data.forEach(record => { if ((record.bloodPressureStatus === 'abnormal' || record.bloodPressureStatus === 'critical') && record.heartRate > 85) { correlations.hypertensionTachycardia++; correlationCount++; } if ((record.oxygenLevelStatus === 'abnormal' || record.oxygenLevelStatus === 'critical') && record.heartRate > 90) { correlations.hypoxiaTachycardia++; correlationCount++; } if ((record.temperatureStatus === 'abnormal' || record.temperatureStatus === 'critical') && record.heartRate > 85) { correlations.feverTachycardia++; correlationCount++; } const criticalSystems = [ record.bloodPressureStatus, record.heartRateStatus, record.oxygenLevelStatus, record.temperatureStatus ].filter(status => status === 'critical' || status === 'abnormal').length; if (criticalSystems >= 2) { correlations.multiSystemCritical++; correlationCount++; } }); const correlationScore = (correlationCount / (totalPatients * 4)) * 100; addDebugLog(`Medical correlation score: ${correlationScore.toFixed(2)}%`, correlationScore > 50 ? 'success' : 'warning'); addDebugLog(`Hypertension-Tachycardia: ${correlations.hypertensionTachycardia} cases`, 'info'); addDebugLog(`Hypoxia-Tachycardia: ${correlations.hypoxiaTachycardia} cases`, 'info'); addDebugLog(`Fever-Tachycardia: ${correlations.feverTachycardia} cases`, 'info'); addDebugLog(`Multi-system critical: ${correlations.multiSystemCritical} cases`, 'info'); }; const handleMethodChange = (e) => { setTrainingMethod(e.target.value); addDebugLog(`Training method changed to: ${e.target.value}`, 'info'); if (e.target.value === 'neural-network') { setTrainingConfig({ iterations: 2000, batchSize: 64, learningRate: 0.005, hiddenLayers: [32, 16, 8], errorThreshold: 0.003, validationSplit: 0.2, regularization: 0.001, momentum: 0.9, dropout: 0.1 }); } else if (e.target.value === 'knn') { setTrainingConfig({ k: 7, distanceMetric: 'euclidean', sampleSize: 15000, weightedVoting: true, featureWeighting: { bloodPressure: 1.2, heartRate: 1.0, oxygenLevel: 1.1, temperature: 0.9 } }); } else if (e.target.value === 'ensemble') { setTrainingConfig({ neuralNetwork: { iterations: 1500, hiddenLayers: [24, 12], learningRate: 0.008, errorThreshold: 0.005 }, knn: { k: 5, distanceMetric: 'euclidean', sampleSize: 10000 }, ensembleWeights: { neuralNetwork: 0.7, knn: 0.3 } }); } }; const handleConfigChange = (e) => { const { name, value } = e.target; if (name === 'hiddenLayers') { const layersArray = value.split(',').map(num => parseInt(num.trim(), 10)).filter(num => !isNaN(num)); setTrainingConfig(prev => ({ ...prev, [name]: layersArray })); addDebugLog(`Hidden layers updated: [${layersArray.join(', ')}]`, 'info'); } else if (['iterations', 'batchSize', 'k', 'sampleSize'].includes(name)) { setTrainingConfig(prev => ({ ...prev, [name]: parseInt(value, 10) })); } else if (['learningRate', 'errorThreshold', 'validationSplit', 'regularization', 'momentum', 'dropout'].includes(name)) { setTrainingConfig(prev => ({ ...prev, [name]: parseFloat(value) })); } else if (name === 'weightedVoting') { setTrainingConfig(prev => ({ ...prev, [name]: value === 'true' })); } else { setTrainingConfig(prev => ({ ...prev, [name]: value })); } }; const trainModel = async () => { try { setIsLoading(true); setTrainingStatus('Preparing realistic health data for training...'); setTrainingError(null); setTrainingProgress(0); setTrainingMetrics({ currentIteration: 0, currentError: 0, validationError: 0, learningRate: trainingConfig.learningRate || 0, timeElapsed: 0, estimatedTimeRemaining: 0, accuracy: 0, classAccuracies: {} }); trainingStartTime.current = Date.now(); addDebugLog('Starting model training on realistic correlated health data...', 'info'); addDebugLog(`Method: ${trainingMethod}`, 'info'); addDebugLog(`Config: ${JSON.stringify(trainingConfig, null, 2)}`, 'info'); if (dataQuality && dataQuality.qualityScore < 50) { addDebugLog('Warning: Low data quality detected. Consider regenerating data with better correlations.', 'warning'); } const response = await fetch(`${API_URL}/train-model`, { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ method: trainingMethod, config: trainingConfig, dataQuality: dataQuality?.qualityScore || 0 }), }); if (!response.ok) { throw new Error(`Failed to start training: ${response.status}`); } const result = await response.json(); if (!result.success) { throw new Error(result.message || 'Failed to start training'); } setTrainingStatus('Training started on realistic health data. This may take several minutes for optimal accuracy...'); addDebugLog(`Training job started with ID: ${result.trainingId}`, 'success'); const trainingId = result.trainingId; const pollInterval = setInterval(async () => { try { const progressResponse = await fetch(`${API_URL}/training-progress/${trainingId}`); const progressData = await progressResponse.json(); if (progressData.completed) { clearInterval(pollInterval); setTrainingProgress(100); if (progressData.success) { setModelInfo({ exists: true, recordCount: progressData.recordCount, iterations: progressData.iterations, error: progressData.error, timestamp: progressData.timestamp, method: progressData.method, accuracy: progressData.accuracy, classAccuracies: progressData.classAccuracies, config: progressData.config }); const successMessage = `Model trained successfully with ${progressData.method}! Overall Accuracy: ${progressData.accuracy.toFixed(2)}% Class Accuracies: Normal: ${progressData.classAccuracies?.normal?.toFixed(1) || 'N/A'}%, Abnormal: ${progressData.classAccuracies?.abnormal?.toFixed(1) || 'N/A'}%, Critical: ${progressData.classAccuracies?.critical?.toFixed(1) || 'N/A'}% Used ${progressData.recordCount.toLocaleString()} realistic records.`; setTrainingStatus(successMessage); addDebugLog(`Training completed successfully!`, 'success'); addDebugLog(`Final accuracy: ${progressData.accuracy.toFixed(2)}%`, 'success'); addDebugLog(`Final error: ${progressData.error?.toFixed(6)}`, 'info'); if (progressData.classAccuracies) { Object.entries(progressData.classAccuracies).forEach(([className, accuracy]) => { addDebugLog(`${className} class accuracy: ${accuracy.toFixed(2)}%`, 'info'); }); } t('Realistic health model training completed successfully!', 3000, '#4CAF50', '#fff'); } else { throw new Error(progressData.error || 'Training failed'); } setIsLoading(false); } else { setTrainingProgress(progressData.progress); setTrainingStatus(`Training in progress: ${progressData.progress}% complete. ${progressData.currentStep || ''}`); const timeElapsed = (Date.now() - trainingStartTime.current) / 1000; const estimatedTotal = progressData.progress > 0 ? (timeElapsed / progressData.progress) * 100 : 0; const estimatedRemaining = Math.max(0, estimatedTotal - timeElapsed); setTrainingMetrics(prev => ({ ...prev, currentIteration: progressData.currentIteration || prev.currentIteration, currentError: progressData.currentError || prev.currentError, validationError: progressData.validationError || prev.validationError, timeElapsed: Math.floor(timeElapsed), estimatedTimeRemaining: Math.floor(estimatedRemaining), accuracy: progressData.accuracy || prev.accuracy, classAccuracies: progressData.classAccuracies || prev.classAccuracies })); if (progressData.currentStep) { addDebugLog(progressData.currentStep, 'info'); } } } catch (error) { console.error('Error checking training progress:', error); addDebugLog(`Progress check error: ${error.message}`, 'error'); } }, 1000); } catch (error) { console.error('Error training model:', error); setTrainingError(`Error training model: ${error.message}`); addDebugLog(`Training error: ${error.message}`, 'error'); setIsLoading(false); t('Training failed: ' + error.message, 5000, '#f44336', '#fff'); } }; const drawNetworkVisualization = () => { const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); const width = canvas.width; const height = canvas.height; ctx.clearRect(0, 0, width, height); const inputSize = 5; const hiddenLayers = trainingConfig.hiddenLayers || [32, 16, 8]; const outputSize = 3; const layers = [inputSize, ...hiddenLayers, outputSize]; const layerLabels = ['Input Layer', ...hiddenLayers.map((_, i) => `Hidden ${i + 1}`), 'Output Layer']; const layerColors = ['#2196F3', '#4CAF50', '#FF9800', '#9C27B0', '#E91E63']; const layerSpacing = width / (layers.length + 1); ctx.strokeStyle = '#E0E0E0'; for (let i = 0; i < layers.length - 1; i++) { const currentLayerX = layerSpacing * (i + 1); const nextLayerX = layerSpacing * (i + 2); const currentLayerSize = layers[i]; const nextLayerSize = layers[i + 1]; ctx.lineWidth = Math.max(0.5, 2 - i * 0.3); for (let j = 0; j < Math.min(currentLayerSize, 20); j++) { const currentY = (height / (Math.min(currentLayerSize, 20) + 1)) * (j + 1); for (let k = 0; k < Math.min(nextLayerSize, 20); k++) { const nextY = (height / (Math.min(nextLayerSize, 20) + 1)) * (k + 1); ctx.beginPath(); ctx.moveTo(currentLayerX, currentY); ctx.lineTo(nextLayerX, nextY); ctx.stroke(); } } } layers.forEach((layerSize, layerIndex) => { const x = layerSpacing * (layerIndex + 1); const nodeRadius = layerIndex === 0 || layerIndex === layers.length - 1 ? 10 : 8; const color = layerColors[Math.min(layerIndex, layerColors.length - 1)]; const displaySize = Math.min(layerSize, 20); ctx.fillStyle = color; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; for (let nodeIndex = 0; nodeIndex < displaySize; nodeIndex++) { const y = (height / (displaySize + 1)) * (nodeIndex + 1); ctx.beginPath(); ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); } if (layerSize > 20) { ctx.fillStyle = '#666'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText('...', x, height - 40); } ctx.fillStyle = '#333'; ctx.font = '12px Arial'; ctx.textAlign = 'center'; ctx.fillText(layerLabels[layerIndex], x, height - 20); ctx.fillText(`(${layerSize})`, x, height - 5); }); ctx.fillStyle = '#666'; ctx.font = '10px Arial'; ctx.textAlign = 'left'; const inputLabels = ['Systolic BP', 'Diastolic BP', 'Heart Rate', 'Oxygen Level', 'Temperature']; const inputX = layerSpacing; inputLabels.forEach((label, i) => { const y = (height / (inputSize + 1)) * (i + 1); ctx.fillText(label, inputX + 15, y + 3); }); const outputLabels = ['Normal', 'Abnormal', 'Critical']; const outputColors = ['#4CAF50', '#FF9800', '#f44336']; const outputX = layerSpacing * layers.length; outputLabels.forEach((label, i) => { const y = (height / (outputSize + 1)) * (i + 1); ctx.fillStyle = outputColors[i]; ctx.fillText(label, outputX + 15, y + 3); }); }; const formatTime = (seconds) => { const mins = Math.floor(seconds / 60); const secs = seconds % 60; return `${mins}:${secs.toString().padStart(2, '0')}`; }; return ( <div className="model-trainer"> <h2>Advanced Training Center</h2> <div className="trainer-description"> <p> TRAIN YOUR MODEL WITH EASE! </p> </div> {/* Data Quality Dashboard */} {dataQuality && ( <div className="data-quality-dashboard"> <h3>Data Quality Analysis</h3> <div className="quality-metrics"> <div className="quality-score"> <div className="score-circle" style={{ background: `conic-gradient(${dataQuality.qualityScore > 80 ? '#4CAF50' : dataQuality.qualityScore > 60 ? '#FF9800' : '#f44336'} ${dataQuality.qualityScore * 3.6}deg, #eee 0deg)` }}> <span className="score-value">{dataQuality.qualityScore.toFixed(0)}%</span> <span className="score-label">Quality</span> </div> </div> <div className="correlation-details"> <h4>Medical Correlations Detected:</h4> {dataQuality.correlations && dataQuality.correlations.percentages && ( <ul> <li>Hypertension → Tachycardia: {dataQuality.correlations.percentages.hypertensionWithTachycardia}%</li> <li>Hypoxia → Compensatory HR: {dataQuality.correlations.percentages.hypoxiaWithTachycardia}%</li> <li>Fever → Increased HR: {dataQuality.correlations.percentages.feverWithTachycardia}%</li> <li>Multi-system Critical: {dataQuality.correlations.percentages.criticalMultiSystem}%</li> <li>Normal Coherence: {dataQuality.correlations.percentages.normalCoherence}%</li> </ul> )} </div> </div> </div> )} {/* Debug Console */} <div className="debug-console"> <div className="debug-header"> <h3>Console</h3> <div className="debug-controls"> <button onClick={clearDebugLogs} className="clear-logs-btn"> Clear Logs </button> <span className="log-count">{debugLogs.length} logs</span> </div> </div> <div className="debug-logs"> {debugLogs.map((log, index) => ( <div key={index} className={`debug-log ${log.type}`}> <span className="log-timestamp">[{log.timestamp}]</span> <span className="log-message">{log.message}</span> </div> ))} </div> </div> {/* Enhanced Training Metrics Dashboard */} {isLoading && trainingProgress > 0 && ( <div className="training-dashboard"> <h3>Real-time Training Metrics</h3> <div className="metrics-grid"> <div className="metric-card"> <div className="metric-value">{trainingMetrics.currentIteration}</div> <div className="metric-label">Current Iteration</div> </div> <div className="metric-card"> <div className="metric-value">{trainingMetrics.currentError.toFixed(6)}</div> <div className="metric-label">Training Error</div> </div> {trainingMetrics.validationError > 0 && ( <div className="metric-card"> <div className="metric-value">{trainingMetrics.validationError.toFixed(6)}</div> <div className="metric-label">Validation Error</div> </div> )} <div className="metric-card"> <div className="metric-value">{formatTime(trainingMetrics.timeElapsed)}</div> <div className="metric-label">Time Elapsed</div> </div> <div className="metric-card"> <div className="metric-value">{formatTime(trainingMetrics.estimatedTimeRemaining)}</div> <div className="metric-label">Est. Time Remaining</div> </div> {trainingMetrics.accuracy > 0 && ( <div className="metric-card"> <div className="metric-value">{trainingMetrics.accuracy.toFixed(2)}%</div> <div className="metric-label">Current Accuracy</div> </div> )} </div> {/* Class-specific accuracy metrics */} {Object.keys(trainingMetrics.classAccuracies).length > 0 && ( <div className="class-accuracies"> <h4>Class-specific Accuracies</h4> <div className="class-metrics"> {Object.entries(trainingMetrics.classAccuracies).map(([className, accuracy]) => ( <div key={className} className="class-metric"> <span className="class-name">{className}:</span> <span className="class-accuracy">{accuracy.toFixed(2)}%</span> </div> ))} </div> </div> )} </div> )} {dataStats && ( <div className="data-stats"> <h3>Dataset Information</h3> <div className="stats-grid"> <div className="stat-card"> <div className="stat-value">{dataStats.totalRecords?.toLocaleString() || 'Unknown'}</div> <div className="stat-label">Total Records</div> </div> {dataStats.sampleSize && ( <div className="stat-card"> <div className="stat-value">{dataStats.sampleSize.toLocaleString()}</div> <div className="stat-label">Sample Analyzed</div> </div> )} </div> {dataStats.distribution && ( <div className="data-distribution"> <h4>Overall Patient Status Distribution</h4> <div className="distribution-bars"> <div className="distribution-item"> <span className="label">Normal Patients:</span> <div className="bar-container"> <div className="bar normal" style={{ width: `${dataStats.distribution.normal}%` }} ></div> <span className="value">{dataStats.distribution.normal}%</span> </div> </div> <div className="distribution-item"> <span className="label">Abnormal Patients:</span> <div className="bar-container"> <div className="bar abnormal" style={{ width: `${dataStats.distribution.abnormal}%` }} ></div> <span className="value">{dataStats.distribution.abnormal}%</span> </div> </div> <div className="distribution-item"> <span className="label">Critical Patients:</span> <div className="bar-container"> <div className="bar critical" style={{ width: `${dataStats.distribution.critical}%` }} ></div> <span className="value">{dataStats.distribution.critical}%</span> </div> </div> </div> </div> )} {/* Individual vital sign distributions */} {dataStats.vitalDistribution && ( <div className="vital-distributions"> <h4>Individual Vital Sign Status Distribution</h4> <div className="vital-grid"> {Object.entries(dataStats.vitalDistribution).map(([vital, counts]) => ( <div key={vital} className="vital-card"> <h5>{vital.toUpperCase()}</h5> <div className="vital-stats"> <div className="vital-stat normal">Normal: {counts.normal}</div> <div className="vital-stat abnormal">Abnormal: {counts.abnormal}</div> <div className="vital-stat critical">Critical: {counts.critical}</div> </div> </div> ))} </div> </div> )} </div> )} {/* Enhanced Neural Network Visualization */} {trainingMethod === 'neural-network' && ( <div className="network-visualization"> <div className="visualization-header"> <h3> Architecture</h3> <button onClick={() => setShowNetworkVisualization(!showNetworkVisualization)} className="toggle-visualization-btn" > {showNetworkVisualization ? 'Hide' : 'Show'} Network </button> </div> {showNetworkVisualization && ( <div className="network-canvas-container"> <canvas ref={canvasRef} width={900} height={500} className="network-canvas" /> <div className="network-info"> <div className="network-details"> <h4>Network Architecture Details</h4> <ul> <li>Input Layer: 5 neurons (correlated vital signs)</li> <li>Hidden Layers: {trainingConfig.hiddenLayers.join(', ')} neurons</li> <li>Output Layer: 3 neurons (health status classification)</li> <li>Total Parameters: {calculateTotalParameters()} weights + biases</li> <li>Activation Function: Sigmoid with dropout</li> <li>Learning Rate: {trainingConfig.learningRate}</li> <li>Regularization: L2 ({trainingConfig.regularization || 0.001})</li> <li>Validation Split: {((trainingConfig.validationSplit || 0.2) * 100)}%</li> </ul> </div> </div> </div> )} </div> )} <div className="training-section"> <h3>Configuration</h3> <div className="training-controls"> <button onClick={fetchHealthDataSample} className="analyze-btn" disabled={isLoading} > {isLoading ? 'Analyzing...' : 'Analyze'} </button> </div> <div className="training-method"> <label htmlFor="trainingMethod">Training Method:</label> <select id="trainingMethod" value={trainingMethod} onChange={handleMethodChange} disabled={isLoading} > <option value="neural-network">Enhanced Neural Network</option> <option value="knn">Optimized K-Nearest Neighbors</option> <option value="ensemble">Ensemble (NN + KNN)</option> </select> <div className="method-description"> {trainingMethod === 'neural-network' ? ( <p>Enhanced neural networks with dropout, regularization, and validation splits. Optimized for realistic medical correlations and pattern recognition in vital signs.</p> ) : trainingMethod === 'knn' ? ( <p>Optimized KNN with weighted voting and feature importance. Excellent for large datasets with clear medical decision boundaries and correlated patterns.</p> ) : ( <p>Ensemble method combining neural network pattern recognition with KNN local similarity matching. Best overall accuracy for complex medical data.</p> )} </div> </div> <div className="training-options"> <div className="options-header" onClick={() => setShowAdvancedOptions(!showAdvancedOptions)}> <h4>Advanced Training Options</h4> <span className={`toggle-icon ${showAdvancedOptions ? 'open' : ''}`}>▼</span> </div> {showAdvancedOptions && ( <div className="advanced-options"> {trainingMethod === 'neural-network' && ( <> <div className="option-row"> <div className="option-group"> <label htmlFor="iterations">Training Iterations:</label> <input type="number" id="iterations" name="iterations" value={trainingConfig.iterations} onChange={handleConfigChange} min="500" max="10000" disabled={isLoading} /> <div className="option-hint">More iterations = better pattern learning</div> </div> <div className="option-group"> <label htmlFor="batchSize">Batch Size:</label> <input type="number" id="batchSize" name="batchSize" value={trainingConfig.batchSize} onChange={handleConfigChange} min="16" max="256" disabled={isLoading} /> <div className="option-hint">Optimal: 32-128 for medical data</div> </div> </div> <div className="option-row"> <div className="option-group"> <label htmlFor="learningRate">Learning Rate:</label> <input type="number" id="learningRate" name="learningRate" value={trainingConfig.learningRate} onChange={handleConfigChange} min="0.0001" max="0.1" step="0.0001" disabled={isLoading} /> <div className="option-hint">0.001-0.01 optimal for health data</div> </div> <div className="option-group"> <label htmlFor="errorThreshold">Error Threshold:</label> <input type="number" id="errorThreshold" name="errorThreshold" value={trainingConfig.errorThreshold} onChange={handleConfigChange} min="0.001" max="0.1" step="0.001" disabled={isLoading} /> <div className="option-hint">Stop when error reaches this level</div> </div> </div> <div className="option-row"> <div className="option-group"> <label htmlFor="validationSplit">Validation Split:</label> <input type="number" id="validationSplit" name="validationSplit" value={trainingConfig.validationSplit} onChange={handleConfigChange} min="0.1" max="0.4" step="0.05" disabled={isLoading} /> <div className="option-hint">Fraction of data for validation</div> </div> <div className="option-group"> <label htmlFor="regularization">L2 Regularization:</label> <input type="number" id="regularization" name="regularization" value={trainingConfig.regularization} onChange={handleConfigChange} min="0" max="0.01" step="0.0001" disabled={isLoading} /> <div className="option-hint">Prevents overfitting</div> </div> </div> <div className="option-row"> <div className="option-group"> <label htmlFor="momentum">Momentum:</label> <input type="number" id="momentum" name="momentum" value={trainingConfig.momentum || 0.9} onChange={handleConfigChange} min="0" max="0.99" step="0.01" disabled={isLoading} /> <div className="option-hint">Accelerates convergence</div> </div> <div className="option-group"> <label htmlFor="dropout">Dropout Rate:</label> <input type="number" id="dropout" name="dropout" value={trainingConfig.dropout || 0.1} onChange={handleConfigChange} min="0" max="0.5" step="0.05" disabled={isLoading} /> <div className="option-hint">Prevents overfitting (0.1-0.3 recommended)</div> </div> </div> <div className="option-row"> <div className="option-group full-width"> <label htmlFor="hiddenLayers">Hidden Layers (comma-separated):</label> <input type="text" id="hiddenLayers" name="hiddenLayers" value={trainingConfig.hiddenLayers.join(', ')} onChange={handleConfigChange} disabled={isLoading} placeholder="e.g. 32, 16, 8" /> <div className="option-hint">Deeper networks capture complex medical correlations</div> </div> </div> </> )} {trainingMethod === 'knn' && ( <> <div className="option-row"> <div className="option-group"> <label htmlFor="k">K Value (Neighbors):</label> <input type="number" id="k" name="k" value={trainingConfig.k} onChange={handleConfigChange} min="3" max="25" disabled={isLoading} /> <div className="option-hint">5-9 optimal for medical classification</div> </div> <div className="option-group"> <label htmlFor="distanceMetric">Distance Metric:</label> <select id="distanceMetric" name="distanceMetric" value={trainingConfig.distanceMetric} onChange={handleConfigChange} disabled={isLoading} > <option value="euclidean">Euclidean (recommended)</option> <option value="manhattan">Manhattan</option> </select> <div className="option-hint">Euclidean works best for normalized vital signs</div> </div> </div> <div className="option-row"> <div className="option-group"> <label htmlFor="sampleSize">Training Sample Size:</label> <input type="number" id="sampleSize" name="sampleSize" value={trainingConfig.sampleSize} onChange={handleConfigChange} min="5000" max="100000" disabled={isLoading} /> <div className="option-hint">Larger samples improve accuracy but slower training</div> </div> <div className="option-group"> <label htmlFor="weightedVoting">Weighted Voting:</label> <select id="weightedVoting" name="weightedVoting" value={trainingConfig.weightedVoting} onChange={handleConfigChange} disabled={isLoading} > <option value="true">Enabled (recommended)</option> <option value="false">Disabled</option> </select> <div className="option-hint">Weight votes by distance for better accuracy</div> </div> </div> </> )} {trainingMethod === 'ensemble' && ( <> <div className="ensemble-config"> <h5>Neural Network Configuration</h5> <div className="option-row"> <div className="option-group"> <label htmlFor="nn_iterations">NN Iterations:</label> <input type="number" id="nn_iterations" name="neuralNetwork.iterations" value={trainingConfig.neuralNetwork?.iterations || 1500} onChange={handleConfigChange} min="500" max="5000" disabled={isLoading} /> </div> <div className="option-group"> <label htmlFor="nn_learningRate">NN Learning Rate:</label> <input type="number" id="nn_learningRate" name="neuralNetwork.learningRate" value={trainingConfig.neuralNetwork?.learningRate || 0.008} onChange={handleConfigChange} min="0.001" max="0.05" step="0.001" disabled={isLoading} /> </div> </div> <h5>KNN Configuration</h5> <div className="option-row"> <div className="option-group"> <label htmlFor="knn_k">KNN K Value:</label> <input type="number" id="knn_k" name="knn.k" value={trainingConfig.knn?.k || 5} onChange={handleConfigChange} min="3" max="15" disabled={isLoading} /> </div> <div className="option-group"> <label htmlFor="knn_sampleSize">KNN Sample Size:</label> <input type="number" id="knn_sampleSize" name="knn.sampleSize" value={trainingConfig.knn?.sampleSize || 10000} onChange={handleConfigChange} min="5000" max="50000" disabled={isLoading} /> </div> </div> <h5>Ensemble Weights</h5> <div className="option-row"> <div className="option-group"> <label htmlFor="nn_weight">Neural Network Weight:</label> <input type="number" id="nn_weight" name="ensembleWeights.neuralNetwork" value={trainingConfig.ensembleWeights?.neuralNetwork || 0.7} onChange={handleConfigChange} min="0.1" max="0.9" step="0.1" disabled={isLoading} /> </div> <div className="option-group"> <label htmlFor="knn_weight">KNN Weight:</label> <input type="number" id="knn_weight" name="ensembleWeights.knn" value={trainingConfig.ensembleWeights?.knn || 0.3} onChange={handleConfigChange} min="0.1" max="0.9" step="0.1" disabled={isLoading} /> </div> </div> </div> </> )} </div> )} </div> <div className="training-actions"> <button onClick={trainModel} className="train-btn" disabled={isLoading || !dataStats?.totalRecords} > {isLoading ? 'Training Enhanced Model...' : 'Train Enhanced Model'} </button> </div> {trainingProgress > 0 && ( <div className="training-progress"> <div className="progress-header"> <div className="progress-label">Training Progress: {trainingProgress}%</div> <div className="progress-percentage">{trainingProgress.toFixed(1)}%</div> </div> <div className="progress-bar-container"> <div className="progress-bar" style={{ width: `${trainingProgress}%` }} > <div className="progress-bar-glow"></div> </div> </div> <div className="progress-details"> <span>Method: {trainingMethod}</span> <span>•</span> <span>Records: {dataStats?.totalRecords?.toLocaleString()}</span> {trainingMetrics.timeElapsed > 0 && ( <> <span>•</span> <span>Elapsed: {formatTime(trainingMetrics.timeElapsed)}</span> </> )} {dataQuality && ( <> <span>•</span> <span>Data Quality: {dataQuality.qualityScore.toFixed(0)}%</span> </> )} </div> </div> )} {trainingStatus && ( <div className="status-message"> <div className="status-icon">ℹ️</div> <div className="status-text">{trainingStatus}</div> </div> )} {trainingError && ( <div className="error-message"> <div className="error-icon">⚠️</div> <div className="error-text">{trainingError}</div> </div> )} </div> {modelInfo && modelInfo.exists && ( <div className="model-info"> <h3>Current Enhanced Model Information</h3> <div className="info-grid"> <div className="info-item"> <span className="info-label">Training Method:</span> <span className="info-value">{modelInfo.method || 'Enhanced Neural Network'}</span> </div> <div className="info-item"> <span className="info-label">Records Used:</span> <span className="info-value">{modelInfo.recordCount?.toLocaleString()}</span> </div> <div className="info-item"> <span className="info-label">Training Iterations:</span> <span className="info-value">{modelInfo.iterations?.toLocaleString()}</span> </div> <div className="info-item"> <span className="info-label">Overall Accuracy:</span> <span className="info-value accuracy-badge"> {modelInfo.accuracy ? `${modelInfo.accuracy.toFixed(2)}%` : 'N/A'} </span> </div> <div className="info-item"> <span className="info-label">Training Error:</span> <span className="info-value">{modelInfo.error?.toFixed(6) || 'N/A'}</span> </div> <div className="info-item"> <span className="info-label">Last Updated:</span> <span className="info-value">{modelInfo.timestamp ? new Date(modelInfo.timestamp).toLocaleString() : 'Unknown'}</span> </div> </div> {/* Class-specific accuracies */} {modelInfo.classAccuracies && ( <div className="class-accuracies-display"> <h4>Class-specific Performance</h4> <div className="class-performance-grid"> {Object.entries(modelInfo.classAccuracies).map(([className, accuracy]) => ( <div key={className} className="class-performance-card"> <div className="class-name">{className.charAt(0).toUpperCase() + className.slice(1)}</div> <div className="class-accuracy">{accuracy.toFixed(2)}%</div> <div className="accuracy-bar"> <div className={`accuracy-fill ${className}`} style={{ width: `${accuracy}%` }} ></div> </div> </div> ))} </div> </div> )} </div> )} </div> ); function calculateTotalParameters() { if (trainingMethod !== 'neural-network') return 0; const layers = [5, ...trainingConfig.hiddenLayers, 3]; let totalParams = 0; for (let i = 0; i < layers.length - 1; i++) { totalParams += (layers[i] * layers[i + 1]) + layers[i + 1]; } return totalParams.toLocaleString(); }
}; export default ModelTrainer; 