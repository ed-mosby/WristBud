import React, { useState, useRef } from 'react';
import './HealthPredictor.css'; const OPENROUTER_API_KEY = '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';
const OPENROUTER_MODEL = 'qwen/qwen-2.5-72b-instruct'; const HealthPredictor = () => { const [isLoading, setIsLoading] = useState(false); const [statusMessage, setStatusMessage] = useState('READY FOR ANALYSIS'); const [errorMessage, setErrorMessage] = useState(null); const [prediction, setPrediction] = useState(null); const [animationPhase, setAnimationPhase] = useState('idle'); const [systolic, setSystolic] = useState(120); const [diastolic, setDiastolic] = useState(80); const [heartRate, setHeartRate] = useState(75); const [oxygenLevel, setOxygenLevel] = useState(98); const [temperature, setTemperature] = useState(36.6); const canvasRef = useRef(null); const animationRef = useRef(null); const particlesRef = useRef([]); const animationStartTimeRef = useRef(0); const networkStructure = { input: 5, hidden: [8, 4], output: 3 }; const canvasWidth = 400; const canvasHeight = 350; const colors = { primary: '#00f0ff', secondary: '#ff00ff', accent: '#ffcc00', background: '#0a0a12', text: '#e0e0e0', warning: '#ff3366', success: '#00ff88', critical: '#ff0040', normal: '#00ff80' }; const analyzeHealthWithAI = async (vitals) => { const prompt = `As a medical AI assistant, analyze these vital signs and provide a structured health assessment: Vital Signs:
- Systolic BP: ${vitals.systolic} mmHg
- Diastolic BP: ${vitals.diastolic} mmHg - Heart Rate: ${vitals.heartRate} BPM
- Oxygen Saturation: ${vitals.oxygenLevel}%
- Body Temperature: ${vitals.temperature}¬∞C Please provide your response in this exact JSON format:
{ "overallStatus": "Normal|Warning|Critical", "riskLevel": "Low|Moderate|High|Severe", "confidence": 85, "probabilities": { "normal": 30, "abnormal": 40, "critical": 30 }, "vitalAnalysis": { "bloodPressure": { "status": "Normal|Elevated|High|Crisis", "concern": "Brief explanation" }, "heartRate": { "status": "Normal|Low|High", "concern": "Brief explanation" }, "oxygenSaturation": { "status": "Normal|Low|Critical", "concern": "Brief explanation" }, "temperature": { "status": "Normal|Fever|Hypothermia", "concern": "Brief explanation" } }, "keyFindings": [ "Most important finding 1", "Most important finding 2" ], "recommendations": [ "Primary recommendation", "Secondary recommendation" ], "urgency": "Routine|Monitor|Seek Care|Emergency"
} Base your analysis on WHO/AHA guidelines. Be precise and clinical.`; try { const response = await fetch('https://openrouter.ai/api/v1/chat/completions', { method: 'POST', headers: { 'Authorization': `Bearer ${OPENROUTER_API_KEY}`, 'Content-Type': 'application/json', 'HTTP-Referer': window.location.origin, 'X-Title': 'Health Analyzer' }, body: JSON.stringify({ model: OPENROUTER_MODEL, messages: [{ role: "user", content: prompt }], max_tokens: 2000, temperature: 0.3 }) }); if (!response.ok) { throw new Error(`Analysis failed: ${response.status}`); } const data = await response.json(); const analysisText = data?.choices?.[0]?.message?.content?.trim(); if (!analysisText) { throw new Error('No analysis received from '); } const jsonMatch = analysisText.match(/\{[\s\S]*\}/); if (!jsonMatch) { throw new Error('Invalid response format from '); } const analysisResult = JSON.parse(jsonMatch[0]); return { success: true, analysis: analysisResult }; } catch (error) { console.error(" Analysis Error:", error); return { success: false, message: error.message || "Failed to analyze health data" }; } }; const calculateNodePositions = () => { const positions = { input: [], hidden: [], output: [] }; const layerSpacing = canvasWidth / (networkStructure.hidden.length + 2); const inputSpacing = canvasHeight / (networkStructure.input + 1); const inputLabels = ['SYSTOLIC', 'DIASTOLIC', 'HEART RATE', 'OXYGEN', 'TEMPERATURE']; for (let i = 0; i < networkStructure.input; i++) { positions.input.push({ x: layerSpacing * 0.5, y: inputSpacing * (i + 1), value: 0, label: inputLabels[i] }); } networkStructure.hidden.forEach((nodeCount, layerIndex) => { const layer = []; const spacing = canvasHeight / (nodeCount + 1); for (let i = 0; i < nodeCount; i++) { layer.push({ x: layerSpacing * (layerIndex + 1.5), y: spacing * (i + 1), value: 0, activation: 0 }); } positions.hidden.push(layer); }); const outputSpacing = canvasHeight / (networkStructure.output + 1); const outputLabels = ['NORMAL', 'WARNING', 'CRITICAL']; for (let i = 0; i < networkStructure.output; i++) { positions.output.push({ x: layerSpacing * (networkStructure.hidden.length + 1.5), y: outputSpacing * (i + 1), value: 0, label: outputLabels[i] }); } return positions; }; const nodePositions = calculateNodePositions(); class Particle { constructor(startX, startY, endX, endY, value, color = colors.primary) { this.startX = startX; this.startY = startY; this.endX = endX; this.endY = endY; this.x = startX; this.y = startY; this.progress = 0; this.speed = 0.002 + Math.random() * 0.003; this.size = 2 + value * 3; this.color = color; this.life = 1; } update() { this.progress += this.speed; this.life = 1 - (this.progress * 0.5); const easeProgress = 1 - Math.pow(1 - this.progress, 2); this.x = this.startX + (this.endX - this.startX) * easeProgress; this.y = this.startY + (this.endY - this.startY) * easeProgress; } draw(ctx) { ctx.save(); ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } isDead() { return this.progress >= 1; } } const drawNetwork = (ctx, inputs, outputs) => { ctx.fillStyle = colors.background; ctx.fillRect(0, 0, canvasWidth, canvasHeight); nodePositions.input.forEach((node, i) => { node.value = inputs[i]; }); if (outputs) { nodePositions.output.forEach((node, i) => { node.value = outputs[i] / 100; }); } drawConnections(ctx); drawNodes(ctx); drawLabels(ctx); }; const drawConnections = (ctx) => { ctx.strokeStyle = colors.primary; ctx.lineWidth = 0.5; ctx.globalAlpha = 0.3; nodePositions.input.forEach(inputNode => { nodePositions.hidden[0].forEach(hiddenNode => { ctx.beginPath(); ctx.moveTo(inputNode.x, inputNode.y); ctx.lineTo(hiddenNode.x, hiddenNode.y); ctx.stroke(); }); }); for (let i = 0; i < networkStructure.hidden.length - 1; i++) { nodePositions.hidden[i].forEach(currentNode => { nodePositions.hidden[i + 1].forEach(nextNode => { ctx.beginPath(); ctx.moveTo(currentNode.x, currentNode.y); ctx.lineTo(nextNode.x, nextNode.y); ctx.stroke(); }); }); } const lastHidden = nodePositions.hidden[nodePositions.hidden.length - 1]; lastHidden.forEach(hiddenNode => { nodePositions.output.forEach(outputNode => { ctx.beginPath(); ctx.moveTo(hiddenNode.x, hiddenNode.y); ctx.lineTo(outputNode.x, outputNode.y); ctx.stroke(); }); }); ctx.globalAlpha = 1; }; const drawNodes = (ctx) => { nodePositions.input.forEach(node => { const size = 8 + node.value * 4; ctx.fillStyle = colors.primary; ctx.beginPath(); ctx.arc(node.x, node.y, size, 0, Math.PI * 2); ctx.fill(); }); nodePositions.hidden.forEach(layer => { layer.forEach(node => { const activation = 0.3 + Math.random() * 0.7; const size = 6 + activation * 3; ctx.fillStyle = colors.secondary; ctx.beginPath(); ctx.arc(node.x, node.y, size, 0, Math.PI * 2); ctx.fill(); }); }); const outputColors = [colors.success, colors.warning, colors.critical]; nodePositions.output.forEach((node, i) => { const size = 10 + node.value * 5; ctx.fillStyle = outputColors[i]; ctx.beginPath(); ctx.arc(node.x, node.y, size, 0, Math.PI * 2); ctx.fill(); if (node.value > 0) { ctx.fillStyle = colors.background; ctx.font = 'bold 10px monospace'; ctx.textAlign = 'center'; ctx.fillText(`${Math.round(node.value * 100)}%`, node.x, node.y + 3); } }); }; const drawLabels = (ctx) => { ctx.fillStyle = colors.text; ctx.font = '10px monospace'; nodePositions.input.forEach(node => { ctx.textAlign = 'right'; ctx.fillText(node.label, node.x - 15, node.y + 3); }); nodePositions.output.forEach(node => { ctx.textAlign = 'left'; ctx.fillText(node.label, node.x + 15, node.y + 3); }); }; const animate = () => { const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext('2d'); const inputs = [ (systolic - 60) / (250 - 60), (diastolic - 40) / (150 - 40), (heartRate - 30) / (200 - 30), (oxygenLevel - 70) / (100 - 70), (temperature - 32) / (45 - 32) ]; const outputs = prediction?.probabilities ? [ prediction.probabilities.normal, prediction.probabilities.abnormal, prediction.probabilities.critical ] : [0, 0, 0]; drawNetwork(ctx, inputs, outputs); particlesRef.current = particlesRef.current.filter(particle => { particle.update(); particle.draw(ctx); return !particle.isDead(); }); if (animationPhase !== 'idle') { animationRef.current = requestAnimationFrame(animate); } }; const startAnimation = () => { if (animationRef.current) { cancelAnimationFrame(animationRef.current); } setAnimationPhase('processing'); particlesRef.current = []; nodePositions.input.forEach(inputNode => { nodePositions.hidden[0].forEach(hiddenNode => { particlesRef.current.push(new Particle( inputNode.x, inputNode.y, hiddenNode.x, hiddenNode.y, Math.random(), colors.primary )); }); }); animate(); }; const makePrediction = async () => { try { setIsLoading(true); setErrorMessage(null); setStatusMessage('ANALYZING VITAL SIGNS...'); setPrediction(null); const vitals = { systolic: parseFloat(systolic), diastolic: parseFloat(diastolic), heartRate: parseFloat(heartRate), oxygenLevel: parseFloat(oxygenLevel), temperature: parseFloat(temperature) }; if (vitals.systolic < 50 || vitals.systolic > 300) { throw new Error('Systolic blood pressure must be between 50-300 mmHg'); } if (vitals.diastolic < 30 || vitals.diastolic > 200) { throw new Error('Diastolic blood pressure must be between 30-200 mmHg'); } if (vitals.heartRate < 20 || vitals.heartRate > 250) { throw new Error('Heart rate must be between 20-250 BPM'); } if (vitals.oxygenLevel < 60 || vitals.oxygenLevel > 100) { throw new Error('Oxygen level must be between 60-100%'); } if (vitals.temperature < 30 || vitals.temperature > 50) { throw new Error('Temperature must be between 30-50¬∞C'); } startAnimation(); const aiResult = await analyzeHealthWithAI(vitals); if (!aiResult.success) { throw new Error(aiResult.message || ' Analysis Failed'); } setPrediction(aiResult.analysis); setStatusMessage(`ANALYSIS COMPLETE - STATUS: ${aiResult.analysis.overallStatus.toUpperCase()}`); setAnimationPhase('complete'); } catch (error) { console.error('Error making prediction:', error); setErrorMessage(`Analysis error: ${error.message}`); setStatusMessage('ANALYSIS FAILED'); setAnimationPhase('idle'); } finally { setIsLoading(false); } }; const getStatusColor = (status) => { switch (status?.toLowerCase()) { case 'normal': return colors.success; case 'warning': return colors.warning; case 'critical': return colors.critical; default: return colors.text; } }; const getVitalStatus = (vital, value) => { switch (vital) { case 'systolic': if (value < 90) return { status: 'LOW', color: colors.critical }; if (value > 140) return { status: 'HIGH', color: colors.warning }; return { status: 'NORMAL', color: colors.success }; case 'diastolic': if (value < 60) return { status: 'LOW', color: colors.critical }; if (value > 90) return { status: 'HIGH', color: colors.warning }; return { status: 'NORMAL', color: colors.success }; case 'heartRate': if (value < 60) return { status: 'LOW', color: colors.warning }; if (value > 100) return { status: 'HIGH', color: colors.warning }; return { status: 'NORMAL', color: colors.success }; case 'oxygenLevel': if (value < 95) return { status: 'LOW', color: colors.critical }; return { status: 'NORMAL', color: colors.success }; case 'temperature': if (value < 36) return { status: 'LOW', color: colors.warning }; if (value > 37.5) return { status: 'HIGH', color: colors.warning }; return { status: 'NORMAL', color: colors.success }; default: return { status: 'UNKNOWN', color: colors.text }; } }; const getRiskLevelColor = (riskLevel) => { switch (riskLevel?.toLowerCase()) { case 'low': return colors.success; case 'moderate': return colors.warning; case 'high': return colors.critical; case 'severe': return colors.critical; default: return colors.text; } }; const getUrgencyColor = (urgency) => { switch (urgency?.toLowerCase()) { case 'routine': return colors.success; case 'monitor': return colors.warning; case 'seek care': return colors.warning; case 'emergency': return colors.critical; default: return colors.text; } }; return ( <div className="health-predictor"> <div className="predictor-header"> <h1>üß† HEALTH ANALYZER</h1> <div className="status-display"> <div className="status-indicator"> <span className={`status-light ${!isLoading ? 'online' : 'processing'}`}></span> <span className="status-text">{statusMessage}</span> </div> <div className="ai-info"> <span>Powered by AI ‚Ä¢ OACR</span> </div> </div> </div> {errorMessage && ( <div className="error-banner"> <span className="error-icon">‚ö†Ô∏è</span> <span>{errorMessage}</span> </div> )} <div className="predictor-content"> <div className="input-section"> <h2>VITAL SIGNS INPUT</h2> <div className="vital-inputs"> <div className="vital-group"> <label>BLOOD PRESSURE</label> <div className="bp-inputs"> <div className="input-field"> <input type="number" value={systolic} onChange={(e) => setSystolic(e.target.value)} min="50" max="300" disabled={isLoading} /> <span className="unit">mmHg</span> <span className="label">SYSTOLIC</span> <div className={`status-badge ${getVitalStatus('systolic', systolic).status.toLowerCase()}`}> {getVitalStatus('systolic', systolic).status} </div> </div> <span className="separator">/</span> <div className="input-field"> <input type="number" value={diastolic} onChange={(e) => setDiastolic(e.target.value)} min="30" max="200" disabled={isLoading} /> <span className="unit">mmHg</span> <span className="label">DIASTOLIC</span> <div className={`status-badge ${getVitalStatus('diastolic', diastolic).status.toLowerCase()}`}> {getVitalStatus('diastolic', diastolic).status} </div> </div> </div> </div> <div className="vital-group"> <label>HEART RATE</label> <div className="input-field"> <input type="number" value={heartRate} onChange={(e) => setHeartRate(e.target.value)} min="20" max="250" disabled={isLoading} /> <span className="unit">BPM</span> <div className={`status-badge ${getVitalStatus('heartRate', heartRate).status.toLowerCase()}`}> {getVitalStatus('heartRate', heartRate).status} </div> </div> </div> <div className="vital-group"> <label>OXYGEN SATURATION</label> <div className="input-field"> <input type="number" value={oxygenLevel} onChange={(e) => setOxygenLevel(e.target.value)} min="60" max="100" step="0.1" disabled={isLoading} /> <span className="unit">%</span> <div className={`status-badge ${getVitalStatus('oxygenLevel', oxygenLevel).status.toLowerCase()}`}> {getVitalStatus('oxygenLevel', oxygenLevel).status} </div> </div> </div> <div className="vital-group"> <label>BODY TEMPERATURE</label> <div className="input-field"> <input type="number" value={temperature} onChange={(e) => setTemperature(e.target.value)} min="30" max="50" step="0.1" disabled={isLoading} /> <span className="unit">¬∞C</span> <div className={`status-badge ${getVitalStatus('temperature', temperature).status.toLowerCase()}`}> {getVitalStatus('temperature', temperature).status} </div> </div> </div> </div> <div className="action-section"> <button onClick={makePrediction} className={`analyze-btn ${isLoading ? 'loading' : ''}`} disabled={isLoading} > {isLoading ? ( <> <span className="loading-spinner"></span> ANALYZING... </> ) : ( <> <span className="analyze-icon">üî¨</span> ANALYZE </> )} </button> </div> </div> <div className="visualization-section"> <h2>PROCESSING</h2> <div className="canvas-container"> <canvas ref={canvasRef} width={canvasWidth} height={canvasHeight} className="network-canvas" /> <div className="animation-overlay"> <div className={`phase-indicator ${animationPhase}`}> {animationPhase === 'processing' && 'PROCESSING...'} {animationPhase === 'complete' && 'ANALYSIS COMPLETE'} {animationPhase === 'idle' && 'READY FOR ANALYSIS'} </div> </div> </div> </div> </div> {prediction && ( <div className="results-section"> <h2> RESULTS</h2> <div className="prediction-summary"> <div className="overall-status"> <div className="status-circle" style={{ backgroundColor: getStatusColor(prediction.overallStatus) }}> <span className="status-text">{prediction.overallStatus.toUpperCase()}</span> </div> <div className="risk-info"> <div className="risk-level" style={{ color: getRiskLevelColor(prediction.riskLevel) }}> <span className="risk-label">RISK LEVEL</span> <span className="risk-value">{prediction.riskLevel.toUpperCase()}</span> </div> <div className="confidence-info"> <span className="confidence-label">CONFIDENCE</span> <span className="confidence-value" style={{ color: colors.accent }}> {prediction.confidence}% </span> </div> <div className="urgency-info" style={{ color: getUrgencyColor(prediction.urgency) }}> <span className="urgency-label">URGENCY</span> <span className="urgency-value">{prediction.urgency.toUpperCase()}</span> </div> </div> </div> <div className="probability-breakdown"> <h3>HEALTH STATUS PROBABILITIES</h3> <div className="probability-bars"> <div className="probability-item"> <span className="prob-label">NORMAL</span> <div className="prob-bar-container"> <div className="prob-bar normal" style={{ width: `${prediction.probabilities.normal}%` }} ></div> <span className="prob-value">{prediction.probabilities.normal}%</span> </div> </div> <div className="probability-item"> <span className="prob-label">ABNORMAL</span> <div className="prob-bar-container"> <div className="prob-bar abnormal" style={{ width: `${prediction.probabilities.abnormal}%` }} ></div> <span className="prob-value">{prediction.probabilities.abnormal}%</span> </div> </div> <div className="probability-item"> <span className="prob-label">CRITICAL</span> <div className="prob-bar-container"> <div className="prob-bar critical" style={{ width: `${prediction.probabilities.critical}%` }} ></div> <span className="prob-value">{prediction.probabilities.critical}%</span> </div> </div> </div> </div> </div> <div className="detailed-analysis"> <div className="vital-analysis-section"> <h3>DETAILED VITAL SIGNS ANALYSIS</h3> <div className="vital-analysis-grid"> {Object.entries(prediction.vitalAnalysis).map(([vital, analysis]) => ( <div key={vital} className="vital-analysis-card"> <div className="vital-name"> {vital.replace(/([A-Z])/g, ' $1').toUpperCase()} </div> <div className={`vital-status ${analysis.status.toLowerCase()}`}> {analysis.status.toUpperCase()} </div> <div className="vital-concern"> {analysis.concern} </div> </div> ))} </div> </div> {prediction.keyFindings && prediction.keyFindings.length > 0 && ( <div className="key-findings-section"> <h3>KEY CLINICAL FINDINGS</h3> <div className="findings-list"> {prediction.keyFindings.map((finding, index) => ( <div key={index} className="finding-item"> <span className="finding-icon">üîç</span> <span className="finding-text">{finding}</span> </div> ))} </div> </div> )} {prediction.recommendations && prediction.recommendations.length > 0 && ( <div className="recommendations-section"> <h3>RECOMMENDATIONS</h3> <div className="recommendations-list"> {prediction.recommendations.map((recommendation, index) => ( <div key={index} className="recommendation-item"> <span className="recommendation-icon">üí°</span> <span className="recommendation-text">{recommendation}</span> </div> ))} </div> </div> )} <div className="disclaimer"> <p> <strong>‚ö†Ô∏è MEDICAL DISCLAIMER:</strong> This AI analysis is for informational purposes only and does not constitute medical advice. Please, always consult with qualified healthcare professionals for medical diagnosis and treatment decisions. </p> </div> </div> </div> )} <div className="quick-presets"> <h3>QUICK TEST SCENARIOS</h3> <div className="preset-buttons"> <button onClick={() => { setSystolic(120); setDiastolic(80); setHeartRate(75); setOxygenLevel(98); setTemperature(36.6); }} className="preset-btn normal" disabled={isLoading} > NORMAL VITALS </button> <button onClick={() => { setSystolic(150); setDiastolic(95); setHeartRate(105); setOxygenLevel(93); setTemperature(38.2); }} className="preset-btn abnormal" disabled={isLoading} > ELEVATED VITALS </button> <button onClick={() => { setSystolic(180); setDiastolic(110); setHeartRate(125); setOxygenLevel(88); setTemperature(39.5); }} className="preset-btn critical" disabled={isLoading} > HIGH RISK VITALS </button> <button onClick={() => { setSystolic(200); setDiastolic(120); setHeartRate(140); setOxygenLevel(82); setTemperature(40.8); }} className="preset-btn emergency" disabled={isLoading} > EMERGENCY VITALS </button> </div> </div> </div> );
}; export default HealthPredictor; 